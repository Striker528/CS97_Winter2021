git clone https://github.com/Striker528/CS97-Assignment6.git

Homework: Topologically ordered commits
Given a git repository, the commits can be thought of as having the structure of a directed acyclic graph (DAG) 
    with the commits being the vertices. 
In particular, one can create a directed edge from each child commit to each of its parent commits. 
Alternatively, one can create a directed edge from each parent to each of its children. 
Note that if a commit is a merge commit, it will have two or even more parents. 
In that case, one has to consider all parents.

Follow these five steps and implement 
(topo_order_commits.py) 
using /usr/local/cs/bin/python3 on the SEASnet GNU/Linux servers.

Discover the .git directory. 

os.getcwd() =returns a string of the current working directory
os.path.exists() =checks if the path exists 
os.path.dirname( 'some path' ) =returns a string of the parent directory from the path

testing:
directory: 
    topo-ordered-commits-test-suite/tests/repo_fixture/example-repo-1
command:
    python3 ../../../../topo_ordered_commits.py

Had to remove all the spaces as they were not configured correctly

git log --all --graph --oneline


Inside a directory, when the script topo_order_commits.py 
    (which doesn’t have to reside in the same directory) is invoked, 
    the script should first determine where the top level Git directory is. 
The top level Git directory is the one containing the .git directory. 
One can do this by looking for .git in the current directory, and if it doesn’t exist search the parent directory, etc. 
This discovery process should only go up, and never descend into a child directory. 
Output a diagnostic ‘Not inside a Git repository’ to standard error and exit with status 1 if 
    .git cannot be found when the search went all the way to the / directory.
Get the list of local branch names. 
Figure out what the different directories inside .git do, particularly the refs and objects directories. 
Beware of branch names with forward slashes. 
    Read §10.2 Git Internals – Git Objects and §10.3 Git Internals – Git References. 
One can use the zlib library in Python to decompress Git objects. 
To simplify this assignment, you can assume that the repository does not use packfiles 
    (see §10.4 Git Internals – Packfiles), i.e., that all its objects are loose.
Build the commit graph. Each commit can be represented as an instance of the CommitNode class, 
    which you can define as follows, and which you are also free to modify or not use at all:

class CommitNode:
    def __init__(self, commit_hash):
        """
        :type commit_hash: str
        """
        self.commit_hash = commit_hash
        self.parents = set()
        self.children = set()
      
The commit graph consists of all the commit nodes from all the branches. 
Each commit node might have multiple parents and children.

In particular, for each branch, perform a depth-first search traversal starting from the branch head 
    (i.e., the commit pointed to by the branch), 
    to establish the parent-child relationships between the commit nodes. 
The traversal should trace through the parents, 
    and for every possible pair of parent and child, 
    add the child hash to the parent node's children, 
    and add the parent hash to the child node's parents. 
The leaf nodes for each branch will be the root commits for that branch, 
    where the leaf nodes are the nodes without any parents. 
Let root_commits be the union of all the leaf nodes across all the branches. 
If a commit is not reachable from any of the branch heads, 
    it should not be part of the commit graph.

Generate a topological ordering of the commits in the graph. 
A topological ordering for our case would be a total ordering of the commit nodes such that 
    all the descendent commit nodes are strictly less than the ancestral commits, 
    where nodes in root_commits are the oldest ancestors. 
One way to generate a topological ordering is to use a depth-first search; see Topological sorting.

Print the commit hashes in the order generated by the previous step, from the least to the greatest. 
If the next commit to be printed is not the parent of the current commit, 
    insert a “sticky end” followed by an empty line before printing the next commit. 
The “sticky end” will contain the commit hashes of the parents of the current commit, 
    with an equal sign “=” appended to the last hash. 
These hashes of the parents, if any, can be printed in any order separated by whitespace. 
If there are no parents, just print an equal sign, “=”. 
This is to inform us how the fragments can be “glued” together.

On the other hand, if an empty line has just been printed, 
    before printing the first commit C in a new segment, print a “sticky start” line starting with an equal sign, “=”, 
    followed by the hashes of the children of C, if any, on the same line in any order and separated by whitespace, 
    so that we know which commits led to commit C. 
There is no whitespace after the equal sign.

Furthermore, if a commit corresponds to a branch head or heads, 
    the branch names should be listed after the commit in lexicographical order, separated by white space. 
Note that this rule does not apply to the hashes in the sticky starts or sticky ends.

The commit hashes in the sticky starts and sticky ends are not considered as part of the sequence of 
    topologically ordered commit output. 
They are printed only as a visual guide. 
So even if a commit hash has already appeared in a sticky start or sticky end, 
    it still must be printed as part of the normal sequence of topologically ordered commit output.

 ['3c25412d2521b8f77778de839acb0350492c3634', '59961945fd47abdcf8d526154befb24810fa9a79', 
 'dd9515b11ebcab015a8a91b494097d06827df5a5', '0e7b5db7a6ebfe3fa72598d0d7919d64bcfc2ab7', 
 '5860da5c2f6181541566190b2f704da20e4753bc', '5fe5a724533a4970c19fa7bc0986c1f646a07e4c', 
 '55bb5940a549a475c768b503cb1b76a6f029d444', 'b5d29544d6c69bc654588fbf22071bdaadbc0d23', 
 '831c585eaada1f7fb3b9f2751b8019dbccc59d94', '127169a28b68c1f09a6f28e289b7aafafe3105a3', 
 'f72697fe0dbf5455b61ab586346578710fbfb6fd', '5e6f9ac703e879de3134990765d2e5dee7ee7ed1', 
 '777e41d9a9ba12b9a485300e16fa4405a4f633c0', '6ad43a64e81fff1fd81de5d2fb6a7c99a71f60a9', 
 'a109cb0e9f18fd0f0106216fccb9c9719e5119db']

586 has to come after 3c25412d2521b8f77778de839acb0350492c3634

* 3c25412 (origin/b12, origin/b11, b12, b11) b11 3
* 5860da5 b11 2
* b5d2954 b11 1
| * 0e7b5db (origin/b9, b9) b9 1
|/
| * 5996194 (HEAD -> b3, origin/z, origin/b4, origin/b3, z, b4) b3 1
| * 5fe5a72 (origin/b2, b2) b2 2
| * 831c585 b2 1
| | * dd9515b (origin/b1, b1) b1 5
| | * 55bb594 b1 4
| |/
| * 127169a (origin/b8, b8) b1 3
| * f72697f b1 2
| * 5e6f9ac b1 1
|/
* 777e41d (origin/master, origin/b13, origin/b10, master, b13, b10) m3
* 6ad43a6 m2
* a109cb0 init

#top to bottom 
#this is a valid topo sort
#bottom parent, above it is a child that has to come before it